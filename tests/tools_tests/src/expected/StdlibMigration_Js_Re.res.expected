let re1 = RegExp.fromString("foo")
let re2 = RegExp.fromString("foo", ~flags="gi")

let flags1 = re2->RegExp.flags
let flags2 = RegExp.flags(re2)

let g1 = re2->RegExp.global
let g2 = RegExp.global(re2)

let ic1 = re2->RegExp.ignoreCase
let ic2 = RegExp.ignoreCase(re2)

let m1 = re2->RegExp.multiline
let m2 = RegExp.multiline(re2)

let u1 = re2->RegExp.unicode
let u2 = RegExp.unicode(re2)

let y1 = re2->RegExp.sticky
let y2 = RegExp.sticky(re2)

let src1 = re2->RegExp.source
let src2 = RegExp.source(re2)

let li1 = re2->RegExp.lastIndex
let () = re2->RegExp.setLastIndex(0)

let exec1 = re2->RegExp.exec("Foo bar")
let exec2 = RegExp.exec(re2, "Foo bar")

let test1 = re2->RegExp.test("Foo bar")
let test2 = RegExp.test(re2, "Foo bar")

// Type alias migration
external reT: RegExp.t = "re"

let matches_access = switch re2->RegExp.exec("Foo bar") {
| None => 0
| Some(r) => RegExp.Result.matches(r)->Array.length
}

let result_index = switch re2->RegExp.exec("Foo bar") {
| None => 0
| Some(r) => RegExp.Result.index(r)
}

let result_input = switch re2->RegExp.exec("Foo bar") {
| None => ""
| Some(r) => RegExp.Result.input(r)
}

